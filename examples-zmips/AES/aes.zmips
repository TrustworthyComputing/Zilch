# s[256] : 5000
# inv_s[256] : 5256
# mul_2[256] : 5512
# mul_3[256] : 5768
# mul_9[256] : 6024
# mul_11[256] : 6280
# mul_13[256] : 6536
# mul_14[256] : 6792
# expandedKey[176] : 7048
# state[16] : 200
# tmp[16] : 216
# ctxt[16] : 100

move $r0, $r0, 0
aes_boxes $r0, $r0, $r0

__init_loop__
    # state[i] = ptxt[i] ^ expandedKey[i];
    lw $r2, 7048($r1)
    secread $r3
    xor $r3, $r3, $r2
    sw $r3, 200($r1)

    add $r1, $r1, 1
    beq $r1, 16, __init_end__ ; if ($r1 == 16) then jump to __init_end__
    j __init_loop__
__init_end__

# 9 Rounds
move $r6, $r6, 200 # state idx
move $r7, $r7, 216 # tmp idx
move $r1, $r1, 1
__round_loop__
# byteSubShiftRow
    # tmp[0] = s[ state[0] ];
    lw $r8, 0($r6)
    lw $r9, 5000($r8)
    sw $r9, 0($r7)
    # tmp[1] = s[ state[5] ];
    lw $r8, 5($r6)
    lw $r9, 5000($r8)
    sw $r9, 1($r7)
    # tmp[2] = s[ state[10] ];
    lw $r8, 10($r6)
    lw $r9, 5000($r8)
    sw $r9, 2($r7)
    # tmp[3] = s[ state[15] ];
    lw $r8, 15($r6)
    lw $r9, 5000($r8)
    sw $r9, 3($r7)
    # tmp[4] = s[ state[4] ];
    lw $r8, 4($r6)
    lw $r9, 5000($r8)
    sw $r9, 4($r7)
    # tmp[5] = s[ state[9] ];
    lw $r8, 9($r6)
    lw $r9, 5000($r8)
    sw $r9, 5($r7)
    # tmp[6] = s[ state[14] ];
    lw $r8, 14($r6)
    lw $r9, 5000($r8)
    sw $r9, 6($r7)
    # tmp[7] = s[ state[3] ];
    lw $r8, 3($r6)
    lw $r9, 5000($r8)
    sw $r9, 7($r7)
    # tmp[8] = s[ state[8] ];
    lw $r8, 8($r6)
    lw $r9, 5000($r8)
    sw $r9, 8($r7)
    # tmp[9] = s[ state[13] ];
    lw $r8, 13($r6)
    lw $r9, 5000($r8)
    sw $r9, 9($r7)
    # tmp[10] = s[ state[2] ];
    lw $r8, 2($r6)
    lw $r9, 5000($r8)
    sw $r9, 10($r7)
    # tmp[11] = s[ state[7] ];
    lw $r8, 7($r6)
    lw $r9, 5000($r8)
    sw $r9, 11($r7)
    # tmp[12] = s[ state[12] ];
    lw $r8, 12($r6)
    lw $r9, 5000($r8)
    sw $r9, 12($r7)
    # tmp[13] = s[ state[1] ];
    lw $r8, 1($r6)
    lw $r9, 5000($r8)
    sw $r9, 13($r7)
    # tmp[14] = s[ state[6] ];
    lw $r8, 6($r6)
    lw $r9, 5000($r8)
    sw $r9, 14($r7)
    # tmp[15] = s[ state[11] ];
    lw $r8, 11($r6)
    lw $r9, 5000($r8)
    sw $r9, 15($r7)
    move $r5, $r5, 0
    __SB_cp_state__ # state[i] = tmp[i];
        lw $r8, $r5($r7)
        sw $r8, $r5($r6)
        add $r5, $r5, 1
        beq $r5, 16, __SB_cp_state_end__ ; if ($r5 == 16) then jump to __SB_cp_state_end__
        j __SB_cp_state__
    __SB_cp_state_end__
# byteSubShiftRow End

# mixColumns
    lw $r2, 0($r6) # ptxt[0]
    lw $r3, 1($r6) # ptxt[1]
    lw $r4, 2($r6) # ptxt[2]
    lw $r5, 3($r6) # ptxt[3]
    # tmp[0] = mul_2[ptxt[0]] ^ mul_3[ptxt[1]] ^ ptxt[2] ^ ptxt[3];
    lw $r8, 5512($r2)
    lw $r9, 5768($r3)
    xor $r8, $r8, $r9
    xor $r8, $r8, $r4
    xor $r8, $r8, $r5
    sw $r8, 0($r7)
    # tmp[1] = ptxt[0] ^ mul_2[ptxt[1]] ^ mul_3[ptxt[2]] ^ ptxt[3];
    lw $r8, 5512($r3)
    lw $r9, 5768($r4)
    xor $r8, $r8, $r9
    xor $r8, $r8, $r2
    xor $r8, $r8, $r5
    sw $r8, 1($r7)
    # tmp[2] = ptxt[0] ^ ptxt[1] ^ mul_2[ptxt[2]] ^ mul_3[ptxt[3]];
    lw $r8, 5512($r4)
    lw $r9, 5768($r5)
    xor $r8, $r8, $r9
    xor $r8, $r8, $r2
    xor $r8, $r8, $r3
    sw $r8, 2($r7)
    # tmp[3] = mul_3[ptxt[0]] ^ ptxt[1] ^ ptxt[2] ^ mul_2[ptxt[3]];
    lw $r8, 5512($r5)
    lw $r9, 5768($r2)
    xor $r8, $r8, $r9
    xor $r8, $r8, $r3
    xor $r8, $r8, $r4
    sw $r8, 3($r7)
    
    lw $r2, 4($r6) # ptxt[4]
    lw $r3, 5($r6) # ptxt[5]
    lw $r4, 6($r6) # ptxt[6]
    lw $r5, 7($r6) # ptxt[7]
    # tmp[4] = mul_2[ptxt[4]] ^ mul_3[ptxt[5]] ^ ptxt[6] ^ ptxt[7];
    lw $r8, 5512($r2)
    lw $r9, 5768($r3)
    xor $r8, $r8, $r9
    xor $r8, $r8, $r4
    xor $r8, $r8, $r5
    sw $r8, 4($r7)
    # tmp[5] = ptxt[4] ^ mul_2[ptxt[5]] ^ mul_3[ptxt[6]] ^ ptxt[7];
    lw $r8, 5512($r3)
    lw $r9, 5768($r4)
    xor $r8, $r8, $r9
    xor $r8, $r8, $r2
    xor $r8, $r8, $r5
    sw $r8, 5($r7)
    # tmp[6] = ptxt[4] ^ ptxt[5] ^ mul_2[ptxt[6]] ^ mul_3[ptxt[7]];
    lw $r8, 5512($r4)
    lw $r9, 5768($r5)
    xor $r8, $r8, $r9
    xor $r8, $r8, $r2
    xor $r8, $r8, $r3
    sw $r8, 6($r7)
    # tmp[7] = mul_3[ptxt[4]] ^ ptxt[5] ^ ptxt[6] ^ mul_2[ptxt[7]];
    lw $r8, 5512($r5)
    lw $r9, 5768($r2)
    xor $r8, $r8, $r9
    xor $r8, $r8, $r3
    xor $r8, $r8, $r4
    sw $r8, 7($r7)
    
    lw $r2, 8($r6) # ptxt[8]
    lw $r3, 9($r6) # ptxt[9]
    lw $r4, 10($r6) # ptxt[10]
    lw $r5, 11($r6) # ptxt[11]
    # tmp[8] = mul_2[ptxt[8]] ^ mul_3[ptxt[9]] ^ ptxt[10] ^ ptxt[11];
    lw $r8, 5512($r2)
    lw $r9, 5768($r3)
    xor $r8, $r8, $r9
    xor $r8, $r8, $r4
    xor $r8, $r8, $r5
    sw $r8, 8($r7)
    # tmp[9] = ptxt[8] ^ mul_2[ptxt[9]] ^ mul_3[ptxt[10]] ^ ptxt[11];
    lw $r8, 5512($r3)
    lw $r9, 5768($r4)
    xor $r8, $r8, $r9
    xor $r8, $r8, $r2
    xor $r8, $r8, $r5
    sw $r8, 9($r7)
    # tmp[10] = ptxt[8] ^ ptxt[9] ^ mul_2[ptxt[10]] ^ mul_3[ptxt[11]];
    lw $r8, 5512($r4)
    lw $r9, 5768($r5)
    xor $r8, $r8, $r9
    xor $r8, $r8, $r2
    xor $r8, $r8, $r3
    sw $r8, 10($r7)
    # tmp[11] = mul_3[ptxt[8]] ^ ptxt[9] ^ ptxt[10] ^ mul_2[ptxt[11]];
    lw $r8, 5512($r5)
    lw $r9, 5768($r2)
    xor $r8, $r8, $r9
    xor $r8, $r8, $r3
    xor $r8, $r8, $r4
    sw $r8, 11($r7)

    lw $r2, 12($r6) # ptxt[12]
    lw $r3, 13($r6) # ptxt[13]
    lw $r4, 14($r6) # ptxt[14]
    lw $r5, 15($r6) # ptxt[15]
    # tmp[12] = mul_2[ptxt[12]] ^ mul_3[ptxt[13]] ^ ptxt[14] ^ ptxt[15];
    lw $r8, 5512($r2)
    lw $r9, 5768($r3)
    xor $r8, $r8, $r9
    xor $r8, $r8, $r4
    xor $r8, $r8, $r5
    sw $r8, 12($r7)
    # tmp[13] = ptxt[12] ^ mul_2[ptxt[13]] ^ mul_3[ptxt[14]] ^ ptxt[15];
    lw $r8, 5512($r3)
    lw $r9, 5768($r4)
    xor $r8, $r8, $r9
    xor $r8, $r8, $r2
    xor $r8, $r8, $r5
    sw $r8, 13($r7)
    # tmp[14] = ptxt[12] ^ ptxt[13] ^ mul_2[ptxt[14]] ^ mul_3[ptxt[15]];
    lw $r8, 5512($r4)
    lw $r9, 5768($r5)
    xor $r8, $r8, $r9
    xor $r8, $r8, $r2
    xor $r8, $r8, $r3
    sw $r8, 14($r7)
    # tmp[15] = mul_3[ptxt[12]] ^ ptxt[13] ^ ptxt[14] ^ mul_2[ptxt[15]];
    lw $r8, 5512($r5)
    lw $r9, 5768($r2)
    xor $r8, $r8, $r9
    xor $r8, $r8, $r3
    xor $r8, $r8, $r4
    sw $r8, 15($r7)
    
    move $r5, $r5, 0
    __MC_cp_state__ # state[i] = tmp[i];
        lw $r8, $r5($r7)
        # print $r8
        sw $r8, $r5($r6)
        add $r5, $r5, 1
        beq $r5, 16, __MC_cp_state_end__ ; if ($r5 == 16) then jump to __MC_cp_state_end__
        j __MC_cp_state__
    __MC_cp_state_end__
# mixColumns End
    
    move $r10, $r10, 0  # counter = 0
    mult $r11, $r1, 16  # loc = rounds*16;
    __xor_expkey__ 
        # state[counter] ^= expandedKey[loc];
        lw $r8, 7048($r11)  # expandedKey[loc]
        lw $r9, $r10($r6)   # state[counter]
        xor $r8, $r8, $r9
        sw $r8, $r10($r6)
        
        add $r11, $r11, 1   # loc++;
        add $r10, $r10, 1   # counter++;
        beq $r10, 16, __xor_expkey_end__ ; if ($r10 == 16) then jump to __xor_expkey_end__
        j __xor_expkey__
    __xor_expkey_end__
    
    add $r1, $r1, 1
    beq $r1, 10, __round_end__ ; if ($r1 == 10) then jump to __round_end__
    j __round_loop__
__round_end__
# End of 9 Rounds

# Final Round
    # byteSubShiftRow
    # tmp[0] = s[ state[0] ];
    lw $r8, 0($r6)
    lw $r9, 5000($r8)
    sw $r9, 0($r7)
    # tmp[1] = s[ state[5] ];
    lw $r8, 5($r6)
    lw $r9, 5000($r8)
    sw $r9, 1($r7)
    # tmp[2] = s[ state[10] ];
    lw $r8, 10($r6)
    lw $r9, 5000($r8)
    sw $r9, 2($r7)
    # tmp[3] = s[ state[15] ];
    lw $r8, 15($r6)
    lw $r9, 5000($r8)
    sw $r9, 3($r7)
    # tmp[4] = s[ state[4] ];
    lw $r8, 4($r6)
    lw $r9, 5000($r8)
    sw $r9, 4($r7)
    # tmp[5] = s[ state[9] ];
    lw $r8, 9($r6)
    lw $r9, 5000($r8)
    sw $r9, 5($r7)
    # tmp[6] = s[ state[14] ];
    lw $r8, 14($r6)
    lw $r9, 5000($r8)
    sw $r9, 6($r7)
    # tmp[7] = s[ state[3] ];
    lw $r8, 3($r6)
    lw $r9, 5000($r8)
    sw $r9, 7($r7)
    # tmp[8] = s[ state[8] ];
    lw $r8, 8($r6)
    lw $r9, 5000($r8)
    sw $r9, 8($r7)
    # tmp[9] = s[ state[13] ];
    lw $r8, 13($r6)
    lw $r9, 5000($r8)
    sw $r9, 9($r7)
    # tmp[10] = s[ state[2] ];
    lw $r8, 2($r6)
    lw $r9, 5000($r8)
    sw $r9, 10($r7)
    # tmp[11] = s[ state[7] ];
    lw $r8, 7($r6)
    lw $r9, 5000($r8)
    sw $r9, 11($r7)
    # tmp[12] = s[ state[12] ];
    lw $r8, 12($r6)
    lw $r9, 5000($r8)
    sw $r9, 12($r7)
    # tmp[13] = s[ state[1] ];
    lw $r8, 1($r6)
    lw $r9, 5000($r8)
    sw $r9, 13($r7)
    # tmp[14] = s[ state[6] ];
    lw $r8, 6($r6)
    lw $r9, 5000($r8)
    sw $r9, 14($r7)
    # tmp[15] = s[ state[11] ];
    lw $r8, 11($r6)
    lw $r9, 5000($r8)
    sw $r9, 15($r7)
    move $r5, $r5, 0
    # byteSubShiftRow End
    __SB_cp_state_fin__     # ctxt[i] = tmp[i] ^ expandedKey[i+160];
        lw $r8, $r5($r7)    # tmp[i]
        lw $r9, 7208($r5)   # expandedKey[i+160]
        xor $r8, $r8, $r9
        sw $r8, 100($r5)    # store ctxt[i]
        print $r8
        add $r5, $r5, 1
        beq $r5, 16, __SB_cp_state_fin_end__ ; if ($r5 == 16) then jump to __SB_cp_state_fin_end__
        j __SB_cp_state_fin__
    __SB_cp_state_fin_end__

# End of Final Round

# # Print Ciphertext
# move $r5, $r5, 0
# __print__
#     lw $r8, 100($r5)
#     print $r8
#     add $r5, $r5, 1
#     beq $r5, 16, __print_end__ ; if ($r5 == 16) then jump to __print_end__
#     j __print__
# __print_end__

answer $r1
